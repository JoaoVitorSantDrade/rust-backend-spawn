# Define o número de workers. 'auto' é a melhor opção, pois usa o número de cores da CPU.
# Esta é uma das otimizações de maior impacto.
worker_processes 6;

# Aumenta o limite de arquivos abertos para os workers, prevenindo erros de "too many open files".
worker_rlimit_nofile 8192;

events {
    # Usa o método de I/O mais eficiente no Linux (geralmente o padrão, mas é bom ser explícito).
    use epoll;
    # Aumenta o número de conexões que cada worker pode manipular.
    worker_connections 2048;
}

http {
    # Otimizações de TCP para envio de pacotes mais eficiente.
    tcp_nopush on;
    tcp_nodelay on;

    # Desabilita o log de acesso. Escrever em disco é uma operação de I/O
    # que pode se tornar um gargalo sob carga extrema.
    access_log off;

    upstream api_servers {
        # least_conn;
        server api01:9999;
        server api02:9999;

        # cada worker, reutilizando-as em vez de criar novas a cada requisição.
        # Isso reduz drasticamente a latência do TCP handshake.
        keepalive 256;
    }

    server {
        listen 9999;
        # Habilitar http2 é bom para a comunicação com o cliente (load balancer).
        http2 on;

        location / {
            proxy_pass http://api_servers;

            # Configuração correta para habilitar o keep-alive com o upstream.
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
        }
    }
}